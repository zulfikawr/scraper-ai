import React, {
  createContext,
  useState,
  useContext,
  ReactNode,
  SetStateAction,
  Dispatch,
  useEffect,
} from "react";
import { HistoryItem, ScrapeStatus, ScrapeResult } from "../types";

interface AppContextType {
  // Stores an array of previously scraped items for the history view
  history: HistoryItem[];
  setHistory: Dispatch<SetStateAction<HistoryItem[]>>;

  // Indicates if any asynchronous operation (like scraping or AI processing) is in progress
  loading: boolean;
  setLoading: Dispatch<SetStateAction<boolean>>;

  // Holds any error message that occurs during the process
  error: string | null;
  setError: Dispatch<SetStateAction<string | null>>;

  // Represents the current stage of the scraping and processing workflow
  status: ScrapeStatus;
  setStatus: Dispatch<SetStateAction<ScrapeStatus>>;

  // Stores the result of the initial web page scrape and cleaning
  scrapeResult: ScrapeResult | null;
  setScrapeResult: Dispatch<SetStateAction<ScrapeResult | null>>;

  // Stores the final Markdown output generated by the AI
  markdown: string;
  setMarkdown: Dispatch<SetStateAction<string>>;

  // Controls whether the results view is maximized to fill the screen
  isMaximized: boolean;
  setIsMaximized: Dispatch<SetStateAction<boolean>>;

  // Tracks the ID of the selected history card for shared layout animation
  selectedHistoryId: string | null;
  setSelectedHistoryId: Dispatch<SetStateAction<string | null>>;
}

const AppContext = createContext<AppContextType | undefined>(undefined);

export const AppProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const [history, setHistory] = useState<HistoryItem[]>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [status, setStatus] = useState<ScrapeStatus>(ScrapeStatus.IDLE);
  const [scrapeResult, setScrapeResult] = useState<ScrapeResult | null>(null);
  const [markdown, setMarkdown] = useState<string>("");
  const [isMaximized, setIsMaximized] = useState<boolean>(false);
  const [isHistoryLoaded, setIsHistoryLoaded] = useState<boolean>(false);
  const [selectedHistoryId, setSelectedHistoryId] = useState<string | null>(
    null,
  );

  // Load history from localStorage on initial render
  useEffect(() => {
    try {
      const savedHistory = localStorage.getItem("history");
      if (savedHistory) {
        setHistory(JSON.parse(savedHistory));
      }
    } catch (error) {
      console.error("Failed to load history from localStorage", error);
    } finally {
      setIsHistoryLoaded(true);
    }
  }, []);

  useEffect(() => {
    if (isHistoryLoaded) {
      try {
        localStorage.setItem("history", JSON.stringify(history));
      } catch (error) {
        console.error("Failed to save history to localStorage", error);
      }
    }
  }, [history, isHistoryLoaded]);

  return (
    <AppContext.Provider
      value={{
        history,
        setHistory,
        loading,
        setLoading,
        error,
        setError,
        status,
        setStatus,
        scrapeResult,
        setScrapeResult,
        markdown,
        setMarkdown,
        isMaximized,
        setIsMaximized,
        selectedHistoryId,
        setSelectedHistoryId,
      }}
    >
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error("useAppContext must be used within an AppProvider");
  }
  return context;
};
